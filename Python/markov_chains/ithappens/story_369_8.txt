
Летняя сессия. Внезапно в полный рост встала необходимость сдавать курсовую работу. Вообще-то на неё отводилось два месяца, но всё это время ваш покорный слуга проводил, как истинный студент, а именно пинал балду. Пояснительная записка с никому не нужной теоретической ерундой у меня была (на неё я время когда-то выделил), а вот программы не было совсем. До сдачи пять дней. Тема работы, к слову, была достаточно серьёзная: анализ данных с помощью искусственных нейронных сетей. Предполагалось, что тему эту я изучу сам (своего рода исследовательская работа в рамках курсовой). На тот момент я имел представление только о том, как работа этой самой сети выглядит со стороны — ознакомился на примере пакета Deductor.Ну что же. За три дня ускоренно изучается загрузка данных из таблиц Экселя с помощью ADO (исходные данные для анализа, пожалованные мне преподавателем, хранились в .xls), пишется оболочка с нехитрым, но солидным интерфейсом, примерно повторяющим виденное в Дедукторе, и прикручивается пара фич для большей напыщенности. В следующие два дня с сайта BaseGroup скачивается прекрасная open-source-библиотека с компонентами, реализующими нейросети в Delphi, быстро вкуривается, прикручивается к проге...И тут встает вопрос: а каким образом оцифровываются данные перед обработкой? Тем более, что они у меня и числовые, и строковые, и «дата-время». Помедитировав, изобрёл метод: для каждого поля считались все уникальные значения, запоминались порядковые номера этих значений и подавались на вход нейросети. То есть обучающий пример выглядел как-то так: «Если в поле_1 значение №1/5 и в поле_2 значение №2/19, то в поле_3 значение № 3/7». Очень неплохая «оцифровка» вышла! Жутко довольный собой, запускаю это дело на тестовый прогон. Что и требовалось доказать: средняя ошибка расчетов более пяти тысяч, что совсем уж некошерно. Кроме того, на выходе сеть выдаёт значения вида 9,999999 и только на седьмом знаке после запятой начинает варьировать цифры. А я-то думал, она мне сейчас такие же порядковые номера выдаст, как я ей позагружал. Наивный... Понимая, что изучить верный метод оцифровки данных за последнюю ночь я не успею, в дело пускаю что? Конечно, Великий Рандом. Конечно, спрятанный табуляцией куда подальше за экран.В итоге программа моя честно открывала базу данных, долго и солидно загружала данные, давала настроить параметры нейросети и столь же честно, долго и старательно обучалась на той лабуде, что я ей скармливал своей гениальной «оцифровкой». Когда же доходило до проверки результатов обучения, программа принимала предложенные ей номера значений из входных полей, выполняла честный расчёт результирующего значения, которое потом успешно забывалось, а в выходные поля подставлялись значения, банально выдернутые рандомом из исходной базы. Чтобы не палиться, что на одних и тех же значениях прога выдаёт каждый раз разные результаты, кнопка «Рассчитать» отключалась после каждого клика, а включалась обратно только после смены входных значений.Вот эту прелесть я и сдал преподавателю. На защите проверялась только работа программы, без демонстрации исходников, поэтому всё прошло отлично. Теперь сижу и молюсь, чтобы никто не додумался сверять результаты моей программы хотя бы с тем же Дедуктором, иначе ко мне могут возникнуть о-о-очень интересные вопросы. А параллельно с молитвами я изучаю оцифровку данных — всё-таки совестно, а то что ж из меня за будущий специалист?


